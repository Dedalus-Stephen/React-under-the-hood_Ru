![0.0](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/0/part-0.svg)

**ReactDOM.render**

Начнем с вызова ReactDOM.render

Это точка вхождения. Я создал простой компонент `<ExampleApplication/>` для дебага. **Первое, что происходит это трансформация JSX в элементы React (React elements).** Они достаточны простые: почти простые объекты с простой структурой. И представляют то, что было возвращено из рендера компонента, ничего более. Некоторые элементы уже возможно вам знакомы: пропсы (props), ключи (keys), рефы (refs). Свойство "type" относится к объекту разметки (markup object), описанного JSX. В нашем случае, это класс `ExampleApplication`, но этим могла бы быть и строка button для тэга Button и так далее. Также, во время воздания React element, React объеденит (merge) `defaultProps` с `props` (если таковые были указаны) и подтвердит (validate) `propTypes`.

Для деталей:

`src\isomorphic\classic\element\ReactElement.js`

**ReactMount**

Модуль, названный `ReactMount`(01), содержит бизнес-логику для монтирования компонентов. На самом деле, никакой бизнес-логики в `ReactDOM` нет, это просто интерфейс для работы с `ReactMount`, так что, когда вы вызываете `ReactDOM.render`, вы технически вызываете `ReactMount.render`. Так о чем же это монтирование?

>Монтирование — это процесс инициализации React компонентов путем создания представляющий из DOM элементов и добавления их в предоставленный контейнер (container).

По крайней мере комментарии в коде именно так это и представляют. Но что это все значит на самом деле? Представьте следующую трансформацию

![0.1_jsx](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/0/mounting-scheme-1-small.svg)

React должен **трансформировать ваши компоненты в HTML** для того, чтобы вставить их в документ (DOM document). Как он этого добивается? Правильно, ему нужно обработать все пропсы **(props), обработчики событий (event handlers), вложенные компоненты (nested components)** и логику компонента. Ему необходимо разбить ваше высокоуровневое описание (компонент) в действительно низкоуровневый формат (HTML), который может быть вставлен на веб-страницу. Это и есть монтирование.

![0.1_jsx](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/0/mounting-scheme-1-big.svg)

Продолжим. Но сначала интересный факт! Украсим наше путешествие, чтобы проходить его было веселее.

>Интересный факт: убедись, что скроллинг (scroll) под контроллем (02)

>Интересная штука, во время первого рендеринга (rendering) корневого компонента (root component) React инициализирует обработчики скроллинга (scroll listeners) и кеширует значение скролла для того, чтобы код приложения имел доступ к ним без повторного запуска. Правда, из-за различных имплементаций рендера в разных браузерах некоторые DOM значения не статичны, они высчитываются каждый раз при их использовании в коде. Конечно, это негативно воздействует на производительность. Эта проблема присуща по большей части для старых браузеров, которые не поддерживают `pageX` и `pageY`. React пытается оптимизировать этот процесс в том числе. 
