![1_0](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/1/part-1-A.svg)

Что ж, экземпляр компонента должен как-то **подключиться** к экосистеме React и, конечно, **оказать на нее соответсвенное влияние.** Для этого существует специальный модуль `React Updates`, который за это ответственнен. **React производит обновления кусками (chunks),** что означает, что он группирует операции и производит их **разом вместе.** И это хорошо, потому что это позволяет ему применять **пре-** и **пост-условия** всего один раз для всей коллекции элементов (кусков) вместо того, чтобы применить их к каждому по отдельности.

Так что же на самом деле занимается этим пре/постпроцессингом? **Транзакции.** Для некоторых это слово или, по крайней мере, его интерпретация в мире UI, может показаться незнакомым, так что давайте сразу немного о нем поговорим. Начнем с простого примера.

Представьте так называемый 'канал связи'. Вы должны отрыть соединение, послать сообщение, закрыть соединение. Это немалый объем работы особенно, когда отправляется большое количество сообщений по-одному. Однако мы может открыть канал всего раз, отправить все ожидающие сообщения и только тогда закрыть его.

![1_1](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/1/communication-channel.svg)

Подумаем об этом в более абстрактном контексте. Представьте, что 'послать сообщение' это любая операция вообще, которую вы хотите применить, а 'открыть/закрыть соединение' — это пре/постпроцессинг протекающий во время выполнения операции. Далее, представьте, что вы можете задать любую пару действий "открытия-закрытия" отдельно и использовать ее с любыми выбранными методами (мы можем назвать их врапперами, потому что фактически каждая пара "обворачивает" операции). Звучит круто!

Вернемся к React. Транзакции это широко используемый паттерн в React. Кроме оборачивания операций они позволяют приложению также сбрасывать поток транзакций, блокировать одновременное выполнение кода, если транзакция уже в прогрессе и т.д. Существует множество разнообразных классов-транзакций, каждая из которых описывает специфичное поведение, но все они расширяются от модуля `Transaction`. Ключевые отличия между ними зависят от списка врапперов каждой из них. Враппер — это всего лишь объект, который содержит методы инициализации и закрытия (открытия соединения и его закрытия).

Процесс таков:

* вызвать `wrapper.initialize` и кешировать возвращенное значение (оно может быть использованно позже)

* вызвать методы, обернутые в транзакцию

* вызвать `wrapper.close`

![1_2](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/1/transaction.svg)

Рассмотрим **другие случаи** применения транзакций в React:

* Сохранение диапазона выбора ввода до/после процесса сверки (reconciliation), восстановление ввода даже в случае непредвиденной ошибки.

* Деактивация событий (events) во время перестановки DOM, предотвращение размытия/фокусировки (blur/focus) с гарантией того, что потом они будут активированны вновь.

* Переноска очереди собранных изменений DOM в основной UI thread после того как сверка завершает свою работу в рабочем треде (worker thread). 

* Вызов всех собранных коллбэков принадлежащих методам/хукам задействованным после обработки (монтирования) нового контента. (Например, `componentDidUpdate`).

Вернемся к нашему конкретному случаю.

React использует `ReactDefaultBatchingStrategyTransaction` (1). Как мы недавно поняли, самое главное в транзакции это его врапперы. Так что мы можем взглянуть на эти врапперы и понять что именно определяет конкретная транзакция. Посмотрим на код: 

```javascript
//\src\renderers\shared\stack\reconciler\ReactDefaultBatchingStrategy.js#19
var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function() {
		ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  },
};

var FLUSH_BATCHED_UPDATES = {
	 initialize: emptyFunction,
	 close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),
}

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
```

Теперь вы знаете как это выглядит. Для этой транзакции нет пре-условий. `initialize` методы пусты, но один из метод методов `clone` достаточно интересный. Он вызывает `ReactUpdates.flushBatchedUpdates`. Что это означает? Так запускается процесс верификации 'грязных' компонентов с последующим ререндерингом. Вы ведь следите? Мы вызываем метод монтирования и оборачиваем его в это конкретную транзакцию, потому что после монтирования React проверяет что было затронуто монтированными компонентами и обновляет их.

Давайте посмотрим на метод, который был обернут в этой транзакции. Что ж, на самом деле он вызывает другую транзакцию...

Alright, we’ve finished Part 1.

![1_3](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/1/part-1.svg)

![1_4](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/1/part-1-B.svg)

![1_5](https://raw.githubusercontent.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/236a844a24f38edc8c3d5c2cb9be53d91e0031dc/stack/images/1/part-1-C.svg)
